<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Introducción on Computación Visual</title><link>https://visualcomputing.github.io/showcase/</link><description>Recent content in Introducción on Computación Visual</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><atom:link href="https://visualcomputing.github.io/showcase/index.xml" rel="self" type="application/rss+xml"/><item><title/><link>https://visualcomputing.github.io/showcase/docs/shortcodes/Shaders/Color_Blend/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://visualcomputing.github.io/showcase/docs/shortcodes/Shaders/Color_Blend/</guid><description>Ejerecicios: Coloring # CMY y RGB # Marco teórico
RGB es un modelo de color basado en la síntesis aditiva, con el que es posible representar un color mediante la mezcla por adición de los tres colores de luz primarios. El modelo CMY es un modelo de color sustractivo que se utiliza en la impresión en colores. Es la versión moderna y más precisa del antiguo modelo tradicional de coloración (RYB).</description></item><item><title/><link>https://visualcomputing.github.io/showcase/docs/shortcodes/Shaders/Lighting/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://visualcomputing.github.io/showcase/docs/shortcodes/Shaders/Lighting/</guid><description>Lighting # Exercise Coloret Ambient light
Implement a scene having the following lighting equation: \mathbf{a} = ambient , ambient4a=ambientambient4, where ambient4ambient4 is the ambient light color.</description></item><item><title/><link>https://visualcomputing.github.io/showcase/docs/shortcodes/Shaders/Procedural_texturing/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://visualcomputing.github.io/showcase/docs/shortcodes/Shaders/Procedural_texturing/</guid><description>Procedural texturing # En computación gráfica, una textura procedimental es una textura creada mediante una descripción matemática (es decir, un algoritmo) en lugar de datos almacenados directamente. La ventaja de este enfoque es el bajo coste de almacenamiento, la resolución ilimitada de las texturas y la facilidad de mapeo de las mismas.
procedural texturing js let pg; let colt; let truchetShader; let colorShader; let brickShader; let dotsShader; let textura; const opcionesS = {&amp;#39;None&amp;#39;: 0, &amp;#39;truchet&amp;#39;:1, &amp;#39;color&amp;#39;:2,&amp;#39;bricks&amp;#39;:3,&amp;#39;dots&amp;#39;:4, &amp;#39;plasma&amp;#39;:5}; function preload() { // shader adapted from here: https://thebookofshaders.</description></item><item><title/><link>https://visualcomputing.github.io/showcase/docs/shortcodes/Shaders/Spacial_Coherence/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://visualcomputing.github.io/showcase/docs/shortcodes/Shaders/Spacial_Coherence/</guid><description>Spacial Coherence # Exercise
Implement your own source dataset and a mechanism to select different images from it.</description></item><item><title/><link>https://visualcomputing.github.io/showcase/docs/shortcodes/Shaders/Texturing/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://visualcomputing.github.io/showcase/docs/shortcodes/Shaders/Texturing/</guid><description>Ejerecicios: Texturing # UV Visualization # Exercise
Redefine the shape texture coordinates to turn the above image upside down.
Exercise
Include the blue channel in the uv visualization (e.g., use blue with red or green channels).
Texture Sampling # HSL( hue, saturation, lightness) y HSV ( hue, saturation, value o HSB con brightness) son formas alternativas de representar el modelo de color RGB.
Hue (Tono): Es el color mismo, definido físicamente por una longitud de onda.</description></item><item><title/><link>https://visualcomputing.github.io/showcase/docs/shortcodes/Workshop_1/Ilusiones/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://visualcomputing.github.io/showcase/docs/shortcodes/Workshop_1/Ilusiones/</guid><description>Workshop #1: Ilusiones Ópticas # Introducción # Una ilusión óptica es una distorsión de la realidad que es percibida por el sentido de la vista. Este tipo de fenómeno ha permitido el estudio de cómo los seres humanos procesan la información. Adicionalmente, a lo largo de la historia se ha buscado recrear y experimentar con los sentidos de esta manera. Lo anterior, es el objetivo del siguiente informe, obteniendo una aproximación, no solo de cómo programar y experimentar con diferentes ilusiones, si no también entender el trasfondo científico que sustentan este comportamiento, consiguiendo la apropiada introducción a la computación visual.</description></item><item><title/><link>https://visualcomputing.github.io/showcase/docs/shortcodes/Workshop_1/Masking/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://visualcomputing.github.io/showcase/docs/shortcodes/Workshop_1/Masking/</guid><description>Workshop #1: Masking # Introducción # El visual masking o enmascaramiento se puede entender como un paradigma, herramienta o fenómeno de percepción visual, el cual es utilizado para la cambiar la apariencia de una imagen mediante una máscara. Para el siguiente informe, teniendo como objetivo el entendimiento y profundización de este concepto como una base de la computación visual, se experimentó con los distintos componentes dados y se propusieron algoritmos que los implementen de forma eficiente.</description></item><item><title/><link>https://visualcomputing.github.io/showcase/docs/shortcodes/Workshop_2/Backroom/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://visualcomputing.github.io/showcase/docs/shortcodes/Workshop_2/Backroom/</guid><description>Workshop #2: 3d webgl application # Introducción # El modelamiento 3D es una herramienta que abre un mundo de posibilidades para representar el mundo real dentro del mundo digital. Inicialmente, los modelos en 2 dimensiones se utilizaban para diseñar todo tipo de invenciones, tales como: juegos, herramientas de desarrollo e incluso modelos de la vida real. Desde hace mucho tiempo, se utiliza el 2D y ha sido muy útil para los desarrolladores.</description></item><item><title/><link>https://visualcomputing.github.io/showcase/Quienes_somos/Andres_Lopez/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://visualcomputing.github.io/showcase/Quienes_somos/Andres_Lopez/</guid><description>Andrés Felipe López # Estudiante de Ingeniería de Sistemas y Computación</description></item><item><title/><link>https://visualcomputing.github.io/showcase/Quienes_somos/Juan_Callejas/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://visualcomputing.github.io/showcase/Quienes_somos/Juan_Callejas/</guid><description>Juan Felipe Callejas # Estudiante de Ingeniería de Sistemas y Computación</description></item><item><title/><link>https://visualcomputing.github.io/showcase/Quienes_somos/Juliette_Lizarazo/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://visualcomputing.github.io/showcase/Quienes_somos/Juliette_Lizarazo/</guid><description>Juliette Sofía Lizarazo # Estudiante de Ingeniería de Sistemas y Computación</description></item><item><title/><link>https://visualcomputing.github.io/showcase/Quienes_somos/Santiago_Sanchez/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://visualcomputing.github.io/showcase/Quienes_somos/Santiago_Sanchez/</guid><description>Santiago Sánchez # Estudiante de Ingeniería de Sistemas y Computación</description></item></channel></rss>