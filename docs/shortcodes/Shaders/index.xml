<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Computación Visual</title><link>https://visualcomputing.github.io/showcase/docs/shortcodes/Shaders/</link><description>Recent content on Computación Visual</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><atom:link href="https://visualcomputing.github.io/showcase/docs/shortcodes/Shaders/index.xml" rel="self" type="application/rss+xml"/><item><title/><link>https://visualcomputing.github.io/showcase/docs/shortcodes/Shaders/Backrooms/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://visualcomputing.github.io/showcase/docs/shortcodes/Shaders/Backrooms/</guid><description>Backrooms # Marco teórico
Se utilizaron dos fragment shaders para incluir dos nuevos modelos de iluminación dentro de los Backrooms.
sketch3.frag // precision mediump float; // // emitted by p5 color-group commands // // https://p5js.org/reference/#group-Color // uniform vec4 uMaterialColor; // uniform vec4 ambient4; // uniform float ambient; // void main() { // // Ambient Light // // gl_FragColor = (ambient + ambient4) * uMaterialColor; // gl_FragColor = (ambient) * uMaterialColor; // } precision mediump float; uniform float ambient; uniform vec4 uMaterialColor; // uLightPosition is given in eye space uniform vec3 uLightPosition; // both, normal3 and position4 are given in eye space as well varying vec3 normal3; varying vec3 position4; void main() { // solve the diffuse light equation discarding negative values // see: https://thebookofshaders.</description></item><item><title/><link>https://visualcomputing.github.io/showcase/docs/shortcodes/Shaders/Color_Blend/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://visualcomputing.github.io/showcase/docs/shortcodes/Shaders/Color_Blend/</guid><description>Ejercicios: Coloring # CMY y RGB # Marco teórico
RGB es un modelo de color basado en la síntesis aditiva, con el que es posible representar un color mediante la mezcla por adición de los tres colores de luz primarios. El modelo CMY es un modelo de color sustractivo que se utiliza en la impresión en colores. Es la versión moderna y más precisa del antiguo modelo tradicional de coloración (RYB).</description></item><item><title/><link>https://visualcomputing.github.io/showcase/docs/shortcodes/Shaders/Lighting/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://visualcomputing.github.io/showcase/docs/shortcodes/Shaders/Lighting/</guid><description>Lighting # Gracias a la iluminación en la computación grafica se puede llegar a dar más detalle a los materiales, imágenes y figuras recreadas en un programa.
Existen dos principales modelos de iluminación, Object oriented lighting (iluminación directa) y Global illumination (iluminación indirecta), el primero se define como el usar una iluminación para un solo objeto, mientras en la segunda da luz a toda la escena.
Exercise Colored Ambient light</description></item><item><title/><link>https://visualcomputing.github.io/showcase/docs/shortcodes/Shaders/Photomosaic/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://visualcomputing.github.io/showcase/docs/shortcodes/Shaders/Photomosaic/</guid><description>Ejercicios: Photomosaic # ASCII art # Marco teórico
Un fotomosaico es una foto compuesta de una colección de imágenes más pequeñas, las cuales son ordenadas de tal manera en que presenten una imagen más grande. El Arte ASCII es un medio artítico donde se utilizan los caracteres que componen al código ASCII para la construcción de imágenes. Este ha sido utilizado cuando no es posible la transmisión de imágenes en dispositivos computarizados que no cuentan con los recursos necesarios, como lo son tarjetas de proceso gráfico.</description></item><item><title/><link>https://visualcomputing.github.io/showcase/docs/shortcodes/Shaders/Procedural_texturing/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://visualcomputing.github.io/showcase/docs/shortcodes/Shaders/Procedural_texturing/</guid><description>Procedural texturing # En computación gráfica, una textura procedimental es una textura creada mediante una descripción matemática (es decir, un algoritmo), en lugar de datos almacenados directamente. La ventaja de este enfoque es el bajo coste de almacenamiento, la resolución ilimitada de las texturas y la facilidad de mapeo de las mismas.
procedural texturing js let pg; let colt; let truchetShader; let colorShader; let brickShader; let dotsShader; let textura; const opcionesS = {&amp;#39;None&amp;#39;: 0, &amp;#39;truchet&amp;#39;:1, &amp;#39;color&amp;#39;:2,&amp;#39;bricks&amp;#39;:3,&amp;#39;dots&amp;#39;:4, &amp;#39;plasma&amp;#39;:5}; function preload() { // shader adapted from here: https://thebookofshaders.</description></item><item><title/><link>https://visualcomputing.github.io/showcase/docs/shortcodes/Shaders/Spatial_Coherence/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://visualcomputing.github.io/showcase/docs/shortcodes/Shaders/Spatial_Coherence/</guid><description>Spatial Coherence # Marco teórico Se define a la coherencia espacial como un fenómeno, donde los objetos y los colores definidos en ellos varían según la distancia y posición del espectador, brindando al mismo un espectro de información más completo sobre su entorno, su profundidad y distribución.
Exercise
Implement your own source dataset and a mechanism to select different images from it.
SpatialCoherence.js &amp;#39;use strict&amp;#39;; let image_src; let video_src; let mosaic; // ui let resolution; let video_on; let mode; let photoSelect; let photoA; function preload() { // paintings are stored locally in the /sketches/shaders/paintings dir // and named sequentially as: p1.</description></item><item><title/><link>https://visualcomputing.github.io/showcase/docs/shortcodes/Shaders/Texturing/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://visualcomputing.github.io/showcase/docs/shortcodes/Shaders/Texturing/</guid><description>Ejercicios: Texturing # UV Visualization # Exercise
Redefine the shape texture coordinates to turn the above image upside down.
UV Visualization js let uvShader; function preload() { // Define geometry directly in clip space (i.e., matrices: Tree.NONE). // Interpolate only texture coordinates (i.e., varyings: Tree.texcoords2). // see: https://github.com/VisualComputing/p5.treegl#handling uvShader = readShader(&amp;#39;/showcase/sketches/SHADERS/UV_v/UV_inv.frag&amp;#39;, { matrices: Tree.NONE, varyings: Tree.texcoords2 }); } function setup() { // shaders require WEBGL mode to work createCanvas(300, 300, WEBGL); noStroke(); // see: https://p5js.</description></item></channel></rss>