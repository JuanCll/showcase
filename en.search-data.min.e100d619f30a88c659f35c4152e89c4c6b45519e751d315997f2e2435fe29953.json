[{"id":0,"href":"/showcase/docs/shortcodes/Workshop_1/Ilusiones/","title":"Ilusiones","section":"Workshop 1","content":" Workshop #1: Ilusiones Ópticas # Introducción # Una ilusión óptica es una distorsión de la realidad que es percibida por el sentido de la vista. Este tipo de fenómeno ha permitido el estudio de cómo los seres humanos procesan la información. Adicionalmente, a lo largo de la historia se ha buscado recrear y experimentar con los sentidos de esta manera. Lo anterior, es el objetivo del siguiente informe, obteniendo una aproximación, no solo de cómo programar y experimentar con diferentes ilusiones, si no también entender el trasfondo científico que sustentan este comportamiento, consiguiendo la apropiada introducción a la computación visual.\nMarco teórico # A lo largo de la historia, se han descubierto muchos tipos de distorsiones que el cerebro humano genera con el fin de poder entender su entorno, como lo son las ilusiones auditivas y las ilusiones ópticas. Para el presente taller, se abordó el estudio de las ilusiones óptivas o visuales.\nUna ilusión, según la RAE, se refiere a:\nEl concepto, imagen o representación sin verdadera realidad, sugeridos por la imaginación o causados por engaño de los sentidos.\nEn el caso de las ilusiones ópticas, este engaño de los sentidos se da debido a los siguientes factores:\nOrganización perceptual: hace referencia a la forma en la que el cerebro organiza las sensaciones entrantes de información. Percepción de profundidad: se basa en cómo la mente intenta dar un sentido de profundidad a imágenes usualmente bidimensionales. Color y brillo: donde el humano, según la iluminación y la constancia del color, percibe la totalidad de un objeto. Objeto: se refiere a que, mientras los objetos conocidos tienen una forma o tamaño consistentes, independientemente de su perspectiva, los desconocidos pueden generar cambios inesperados según el punto de vista. Percepción futura: Se teoriza que una razón de las ilusiones ópticas son el retraso neuronal, causado por el tiempo en el que tarda en llegar la luz a la retina, esto siendo compensado por el cerebro generando imágenes de, lo que cree, puede ocurrir en milésimas de segundo en el futuro. -Artículo de Wikipedia\nAdicionalmente, se ha hecho una clasificación de las ilusiones visuales de esta manera:\nIlusiones ópticas fisiológicas: Se asocian a los efectos de una excesiva estimulación en los ojos, dadas por el color, el brillo y el movimiento. Ilusiones ópticas cognitivas: Se refieren a las relacionadas con una vulnerabilidad de la visión que exige al cerebro el entendimiento de algo que no considera claro. Ilusiones de ambiguedad: Son figuras que presentan dos alternativas de percepción no simultáneas. Ilusiones de distorsión: Se basan en los errores de percepción de un objeto o imagen. Ilusiones paradójicas: Presentan objetos imposibles. Ilusiones ficticias: Son aquellas que inducen al cerebro a la alucinación, debido a la inducción de alteraciones mentales. -Artículo de Blog XCARET\nMétodo # Como se explicó en el marco teórico, las ilusiones mostradas en este taller son ilusiones visuales, donde se perciben dichas ilusiones gracias al engaño a los sentidos. Asimismo, tenemos que la construcción de dichas ilusiones cognitivas (para este caso) dependen de dos factores:\nNo hay movimiento inducido Hay movimiento inducido En el caso de no hay movimiento inducido, se utilizan en todo momento dos funciones:\nPara crear el entorno la función setup(). function setup() { // Creación del canvas createCanvas(width, height) } Para la creación de los obtejos dentro del entorno canvas la función draw(). function draw() { // El píncel, aquí se dibujan líneas, establecen colores y se define la posición de los componentes ... ... } En este caso, únicamente se ubican componentes estáticos dentro del canvas. La ilusión es cognitiva pero todo el movimiento o dinamismo es generado por el \u0026ldquo;engaño \u0026quot; al cerebro inducido por el conjunto de componentes incluidos en la ilusión.\nEn el caso de hay movimiento inducido, se utilizan las mismas funciones y una más que sirve para interactuar con el usuario directamente.\nLa función mousePressed() se utiliza para definir en qué momentos el usuario puede hacer click en la pantalla y visualizará un cambio dinámico no generado por el cerebro, sino que será un cambio necesario para que se pueda notar el efecto de la ilusión. En el caso de la ilusión de los cuadrados rotando, se parte de utilizar la función draw() y una variable x dentro de un bucle for(){} para inducir movimiento a los cuadrados y hacerlos rotar en empezar a crecer a medida que avance el tiempo. Sin embargo, una variable a = true nos indica que el movimiento está activado, y es la función mousePressed() la encargada de llevarla a valor a = false y así ejecutar el siguiente código: function mousePressed() { if (a == false) { noLoop(); a = true; } else { loop(); a = false; } } Son entonces las funciones noLoop() y loop() las encargadas de parar y reanudar respectivamente, el movimiento inducido en la ilusión. Y es al parar la ilusión cuando se percibe el efecto de la ilusión.\nNOTA: La ilusión cuadrados rotando fue diseñada de forma accidental al realizar pruebas de construcción de componentes en el editor de p5. Más adelante se discuten las posibles causas de dicha ilusión.\nResultados # Ilusión lineas rectas # Únicamente con lineas rectas se consigue generar aparentes curvas. Se denomina curvas de Bézier a un sistema que se desarrolló hacia los años 1960 para el trazado de dibujos técnicos, en el diseño aeronáutico y en el de automóviles. Su denominación es en honor a Pierre Bézier, quien ideó un método de descripción matemática de las curvas que se comenzó a utilizar con éxito en los programas de CAD. Las curvas de Bézier han sido ampliamente usadas en los gráficos generados por ordenador para modelado de curvas suaves. -Articulo de Wikipedia p5-lines //{{\u0026lt; p5-iframe sketch=\u0026#34;/showcase/sketches/illusion_lines.js\u0026#34; width=\u0026#34;525\u0026#34; height=\u0026#34;525\u0026#34; \u0026gt;}} function setup() { createCanvas(500, 500); } function draw() { background(220); for(var i1=0;i1\u0026lt;500;){ line(0, i1, 10+i1, 500); i1+=10; } for(var i2=0;i2\u0026lt;500;){ line(500, 10+i2, i2, 0); i2+=10; } for(var i3=0;i3\u0026lt;500;){ line(0, 500-i3, 10+i3, 0); i3+=10; } for(var i4=0;i4\u0026lt;500;){ line(500-i4, 500, 500, i4); i4+=10; }\t} Ilusión de cuadricula # Ilusión psicológica en la cual se ven puntos en las intersecciones que aparecen y desaparecen. La ilusión de la cuadrícula de Hermann fue observada por Ludimar Hermann en 1870. Es muy similar a la anterior, cuando se mira un dibujo con una cuadrícula blanca sobre un fondo negro, se tiene la impresión de que surgen manchas \u0026ldquo;fantasmas\u0026rdquo; en las intersecciones de las líneas. Las manchas desaparecen cuando se observa directamente la intersección. Eso explica por qué se ven puntos en la intersección. -Articulo de Wikipedia\nAunque no hay una respuesta definitiva, se cree que ocurre por un proceso de inhibición neural lateral, en el que no interviene una sola célula o receptor en el campo visual, sino todo un conjunto de células que reaccionan ante los estímulos que se presentan. -Psicoactiva\np5-grid //{{\u0026lt; p5-iframe sketch=\u0026#34;/showcase/sketches/illusion_Grid.js\u0026#34; width=\u0026#34;445\u0026#34; height=\u0026#34;445\u0026#34; \u0026gt;}} function setup() { createCanvas(420, 420); } function draw() { background(\u0026#34;white\u0026#34;); for(var i=0; i \u0026lt; 400;) { for(var j=0; j\u0026lt;400; ){ rect(i, j, 20, 10); rect(i, j+20, 20, 10); j+=30 } fill(\u0026#34;black\u0026#34;); i+=30 } } Ilusión de paralelas # La ilusión de la pared de la cafetería es un tipo de ilusión óptico-geométrica, en la que líneas rectas paralelas, que dividen líneas entre filas formadas por baldosas blancas y negras alternas y escalonadas, aparentan estar inclinadas.\nLa ilusión fue atribuida en gran parte al fenómeno de la irradiación, y a la dispersión de la luz entre zonas oscuras y zonas brillantes en la imagen retinal.\nLa primera vez que se reporto esta ilusion fue en una pared de una cafetería, e incluso la fachada de un edificio en Melbourne utiliza esta ilusión. -Articulo de Wikipedia\np5-paralelas //{{\u0026lt; p5-iframe sketch=\u0026#34;/showcase/sketches/illusion_paralelas.js\u0026#34; width=\u0026#34;420\u0026#34; height=\u0026#34;425\u0026#34; \u0026gt;}} function setup() { createCanvas(400, 400); } function draw() { background(\u0026#34;white\u0026#34;); for (var i = 0; i \u0026lt; 400; i+=20) { line(0,20+i,400,20+i) } for (var j = 0; j \u0026lt; 50; j+=10) { for (var k = 0; k \u0026lt; 400; k+=50) { rect(0+(k+j/5), 20+j+j, 25, 20); rect(0+(k+10-j/5), 120+j+j, 25, 20); rect(0+(k+j/5), 220+j+j, 25, 20); rect(0+(k+10-j/5), 320+j+j, 25, 20); line(0,10,400,10) stroke(\u0026#34;gray\u0026#34;) fill(\u0026#34;black\u0026#34;) } } } El efecto desaparece cuando el blanco y el negro son reemplazados por colores diferentes, pero del mismo brillo. Ilusión cuadrado que \u0026ldquo;respira\u0026rdquo; # Ilusión óptica en la cual por la rotación y la visión limitada sobre el cuadrado pareciera que el tamaño de este mismo cambia. La falta de información del objeto completo hace que las imagenes rotando tengan un efecto de pulsaciones generado por la habilidad que tiene el cerebro de realizar interpolaciones de objetos en el espacio.\n-Breathing Square\np5-square //{{\u0026lt; p5-iframe sketch=\u0026#34;/showcase/sketches/breathing_square.js\u0026#34; width=\u0026#34;425\u0026#34; height=\u0026#34;425\u0026#34; \u0026gt;}} let angle = 0; function setup() { createCanvas(400, 400); angleMode(DEGREES); // stroke(\u0026#39;black\u0026#39;); noStroke(); } function draw() { background(252, 255, 216); push(); translate(200, 200); rotate(angle); fill(17, 0, 255); rectMode(CENTER); rect(0, 0, 200, 200); angle = angle + 3; pop(); if (!mouseIsPressed) { rectMode(CORNER); fill(255, 153, 55); rect(0, 0, 180, 180); rect(220, 0, 180, 180); rect(0, 220, 180, 180); rect(220, 220, 180, 180); } } Ilusión cuadrados rotando # En este caso, después de observar el punto en el centro de los cuadrados rotanto durante un tiempo, una vez pausado, se produce una sensación de movimiento en sentido contrario y mucho más lento. En este caso, se relacionó este efecto al fenomeno de afterimage, que si bien no es exactamente igual, puede tener similitudes en cómo funciona. Además, se pueden relacionar a ilusiones en las que se encuentran una gran cantidad de figuras geométricas iguales y tonalidades de color distintas, lo que hace que el cerebro reciba mucha información simultánea y de lugar a estos efectos. p5-squares //{{\u0026lt; p5-iframe sketch=\u0026#34;/showcase/sketches/squares_rotating.js\u0026#34; width=\u0026#34;625\u0026#34; height=\u0026#34;625\u0026#34; \u0026gt;}} function setup() { createCanvas(600, 600); // rectMode(CENTER); x_0 = 0; y_0 = 255; a = true; } function draw() { background(0); push(); translate(width / 2, height / 2); for (let x = 420; x \u0026gt;= 40; x = x / 1.08) { noStroke(); rotate(radians(frameCount / 2)); fill(y_0, 40); rect(0, 0, x, x); } pop(); point(300, 300); stroke(\u0026#34;blue\u0026#34;); strokeWeight(10); } function mousePressed() { if (a == false) { noLoop(); a = true; } else { loop(); a = false; } } Discusión # A partir de los resultados obtenidos, se discutieron los siguientes puntos:\nLas aplicaciones de las ilusiones ópticas:\nSegún lo visto en la sección marco teórico, se inició una discusión alrededor de las aplicaciones de las ilusiones ópticas. De ella y de la consulta de información al respecto, se obtuvo que las ilusiones ópticas funcionan como un recurso para el entendimiento del cerebro, a pesar de que varíen las conexiones neuronales entre persona y persona, hallando que no todas las personas perciben dichas ilusiones de la misma manera. - Presentación sobre ilusiones ópticas La creación de nuevas ilusiones ópticas:\nEl desarrollo del taller, junto con la experimentación y aprendizaje del lenguaje p5.js, permitió la creación de una ilusión visual que no se encontró durante la investigación del tema. Una vez encontrada la distorsión de la imagen, se comenzó una experimentación con la misma, lo cual permitió aprender de manera experimental la forma en la que los integrantes del grupo reaccionamos ante diferentes estímulos como lo son: la luz, el color, la forma y la velocidad de los elementos involucrados. Adicionalmente, se generó una consulta sobre ilusiones ópticas creadas recientemente, encontrando una gran cantidad de ilusiones y de concursos que se enfocan en esta área. - Concurso de ilusiones ópticas Conclusiones # Se puede concluir del presente informe, que la realización y entendimiento de las ilusiones ópticas, permite la experimentación con aspectos visuales como lo son la iluminación, el color, la sombra y el movimiento, los cuales son tópicos fundamentales en el estudio de todo lo relacionado a lo visual, en este caso a la programación enfocada a este campo. Finalmente, se pudo observar a lo largo del desarrollo del taller, las implicaciones a nivel mental y físico que las ilusiones ópticas generan, no solo a nivel experimental, sino desde el aspecto académico.\n"},{"id":1,"href":"/showcase/docs/shortcodes/Workshop_1/Masking/","title":"Masking","section":"Workshop 1","content":" Workshop #1: Masking # Introducción # El visual masking o enmascaramiento se puede entender como un paradigma, herramienta o fenómeno de percepción visual, el cual es utilizado para la cambiar la apariencia de una imagen mediante una máscara. Para el siguiente informe, teniendo como objetivo el entendimiento y profundización de este concepto como una base de la computación visual, se experimentó con los distintos componentes dados y se propusieron algoritmos que los implementen de forma eficiente.\nMarco teórico # Image Kernels # En procesamiento de imágenes un kernel, matriz de convolución o mask es una matriz utilizada para realizar ciertos cambio en una imagen. Esto, se consigue haciendo una convolución entre la imagen y el kernel.\nUna convolución es un proceso matemático, en el cual cada elemento de la imagen se suma con sus vecinos y se opera con la matriz. -Articulo de Wikipedia\nLa convolución puede ser aplicada a dos funciones cualesquiera de tiempo o espacio (u otras variables) para arrojar una tercera función: la salida de la convolución. -Energy Glossary\\ Lightness # La luminosidad, también llamada claridad, es una propiedad de los colores. Ella da una indicación sobre el aspecto luminoso del color estudiado: cuanto más oscuro es el color, la luminosidad es más débil. Sin embargo, se le puede dar más de una definición, una de las más simples, por ejemplo, es el promedio aritmético entre sus tres componentes en el modelo RGB. -Articulo de Wikipedia Para aumentar el brillo utilice la tecla \u0026ldquo;+\u0026rdquo;, para disminuirlo utilice la tecla \u0026ldquo;-\u0026rdquo; Image Histogram # Un histograma de imagen es un tipo de histograma que actúa como una representación gráfica de la distribución tonal de una imagen digital. El eje horizontal representa las variaciones tonales, mientras que el eje vertical representa el número total de pixeles en un tono en particular. En la parte izquierda del eje horizontal se encuentran las áreas más oscuras y en la parte derecha las más luminosas. Estos histogramas tienen diferentes aplicaciones en edición y procesamiento de imágenes. -Articulo de Wikipedia Método # Image Kernels # Para el desarrollo de esta parte del taller, se usaron 5 funciones:\nPara cargar la imagen seleccionada a procesar: preload() function preload() { img = loadImage('Images/images11.jpg'); } Para inicializar el canvas y los elementos del programa setup() function setup() { //Creation of the selection dropdown, to choose the kernel sel = createSelect(); //sel.position(10, 10); sel.option('Identity'); sel.option('Ridge detection'); sel.option('Sharpen'); sel.option('Blur'); sel.option('Convolution'); sel.option('Unsharp masking'); //Creation of canvas and a new empty image createCanvas(400, 200); pixelDensity(1); newimg = createImage(img.width, img.width); } Para crear y recorrer la imagen: draw() function draw() { //Gray empty canvas background(225); image(img, 0, 0); //Load original and new empy image newimg.loadPixels(); img.loadPixels(); if (sel.value() !== 'Identity') { //Establish the values of the wanted matrix matrix = selection(sel.value())[0]; //Establish the size of the kernel let sizem = selection(sel.value())[1]; //Loop through the image matrix for (var x = 0; x \u0026lt; newimg.width; x++) { for (var y = 0; y \u0026lt; newimg.height; y++) { //Get the colors resulting from the convolution let c = convolution(img, x, y, matrix, sizem); //Get the index from the matrix with pixelDensity = 1 var index = (y * newimg.width + x) * 4; //Set the new colors to the corresponding pixels newimg.pixels[index] = c[0]; newimg.pixels[index + 1] = c[1]; newimg.pixels[index + 2] = c[2]; newimg.pixels[index + 3] = 255; } } //Update de image newimg.updatePixels(); //Create a new image in the right half of the canvas image(newimg, width/2, 0); } else { //If the option is identity there's no need to loop the image image(img, width/2, 0); } } Vale la pena resaltar la fórmula para hallar el índice del pixel que se está evaluando:\nindex = (x + img.width * y)*4\nEsto, debido a que la matriz es la ventana de visualización x4, lo que implica que los primeros 4 índices, corresponderán a los valores R, G, B, A del píxel (0,0) (Esto asumiendo que la densidad del pixel será de 1), avanzando por pixel de 4 en 4.\nPara realizar la convolución: convolution(img, x, y, matrix, sizem) function convolution(img, x, y, matrix, sizem) { //Funcion that multiplies the current values with the kernel chosen //Declare de variables let r = 0.0; let g = 0.0; let b = 0.0; //Loop through the kernel for (var i = -1; i \u0026lt; sizem - 1; i++) { for (var j = -1; j \u0026lt; sizem - 1; j++) { let px = x + i; let py = y + j; //Calculate the index let index = (px + img.width * py)*4; //Make sure the index stays inside the range index = constrain(index, 0, img.pixels.length - 1); //Multiply the corresponding pixels with the kernel r += img.pixels[index] * matrix[i+1][j+1]; g += img.pixels[index + 1] * matrix[i+1][j+1]; b += img.pixels[index + 2] * matrix[i+1][j+1]; } } return [r,g,b]; } Para seleccionar un kernel: selection(value) function selection(value) { //Function that returns the chosen kernel and its size switch (value) { case 'Ridge detection': matrix = [ [ -1, -1, -1 ], [ -1, 8, -1 ], [ -1, -1, -1 ] ]; sizem = 3; break; case 'Sharpen': matrix = [ [ 0, -1, 0 ], [ -1, 5, -1 ], [ 0, -1, 0 ] ]; sizem = 3; break; case 'Blur': matrix = [ [ 1/9, 1/9, 1/9 ], [ 1/9, 1/9, 1/9 ], [ 1/9, 1/9, 1/9 ] ]; sizem = 3; break; case 'Convolution': matrix = [ [ -1, -1, -1 ], [ -1, 9, -1 ], [ -1, -1, -1 ] ]; sizem = 3; break; case 'Unsharp masking': matrix = [ [ -1/256, -4/256, -6/256, -4/256, -1/256 ], [ -4/256, -16/256, -24/256, -16/256, -4/256 ], [ -6/256, -24/256, 476/256, -24/256, -6/256], [ -4/256, -16/256, -24/256, -16/256, -4/256 ], [ -1/256, -4/256, -6/256, -4/256, -1/256 ]]; sizem = 5; break; default: matrix = [ [ -1, -1, -1 ], [ -1, 9, -1 ], [ -1, -1, -1 ] ]; sizem = 3; break; } return [matrix, sizem] } Lightness and Image Histogram # A partir del desarrollo de la sección anterior, se pudo lograr el segundo y tercer ítem. Se cambiaron y agregaron los siguientes componentes:\nPara crear y establecer el histograma de la imagen: draw() function draw() { var rango = 256; image(img, 0, 0); var histogram = new Array(rango); for (i = 0; i \u0026lt;= rango; i++) { histogram[i] = 0; } loadPixels(); for (var x = 0; x \u0026lt; img.width; x+=5) { for (var y = 0; y \u0026lt; img.height; y+=5) { var indice = (x + y * img.width) * 4; var a = pixels[indice]; var a2 = pixels[indice + 1]; var a3 = pixels[indice + 2]; var a4 = pixels[indice + 3]; b = int(a3); histogram[b]++; } } image(img, 0, 0); stroke(250,20,200); push(); translate(10,0) for (x = 0; x \u0026lt;= rango; x++) { index = histogram[x]; y1=int(map(index, 0, max(histogram), height, height-200)); y2 = height; xPos = map(x,0,rango,0, width-20); line(xPos, y1, xPos, y2); } pop(); } Para cambiar el brillo de la imagen: brillo(masomenos) function brillo(masomenos){ img.loadPixels(); for (var x = 0; x \u0026lt; img.width; x++) { for (var y = 0; y \u0026lt; img.height; y++) { var index = (y * img.width + x) * 4; if(masomenos){ img.pixels[index] = constrain(img.pixels[index]*1.1,0,255); img.pixels[index+1] = constrain(img.pixels[index+1]*1.1,0,255); img.pixels[index+2] = constrain(img.pixels[index+2]*1.1,0,255); } else{ img.pixels[index] = constrain(img.pixels[index]/1.1,0,255); img.pixels[index+1] = constrain(img.pixels[index+1]/1.1,0,255); img.pixels[index+2] = constrain(img.pixels[index+2]/1.1,0,255); } } } img.updatePixels(); image(img, width/2, 0); } Configurar el las teclas + y - para ajustar el brillo: keyPressed() function keyPressed() { switch (key) { case \u0026quot;+\u0026quot;: brillo(true); break; case \u0026quot;-\u0026quot;: brillo(false); break; } } Resultados # Aplicación con todos los casos anteriores juntos # p5-kernel image processing let img; let newimg; let d; let sel; function preload() { img = loadImage(\u0026#39;/showcase/sketches/perro_foto_dim.jpg\u0026#39;); } function setup() { //Creacion del menu para seleccionar kernel sel = createSelect(); sel.option(\u0026#39;Identity\u0026#39;); sel.option(\u0026#39;Ridge detection\u0026#39;); sel.option(\u0026#39;Sharpen\u0026#39;); sel.option(\u0026#39;Blur\u0026#39;); sel.option(\u0026#39;Convolution\u0026#39;); sel.option(\u0026#39;Unsharp masking\u0026#39;); createCanvas(500, 410); pixelDensity(1); newimg = createImage(img.width, img.width); } function draw() { background(225); image(img, 0, 0); let sizem = 3; newimg.loadPixels(); img.loadPixels(); /*xm = mouseX; ym = mouseY; */ if (sel.value() !== \u0026#39;Identity\u0026#39;) { matrix = selection(sel.value()); for (var x = 0; x \u0026lt; newimg.width; x++) { for (var y = 0; y \u0026lt; newimg.height; y++) { let c = convolution(img, x, y, matrix, sizem); var index = (y * newimg.width + x) * 4; newimg.pixels[index] = c[0]; newimg.pixels[index + 1] = c[1]; newimg.pixels[index + 2] = c[2]; newimg.pixels[index + 3] = 255; } } newimg.updatePixels(); image(newimg, width/2, 0); } else { image(img, width/2, 0); } var rango = 256 image(newimg, 0, 0); var histogram = new Array(rango); for (i = 0; i \u0026lt;= rango; i++) { histogram[i] = 0 } loadPixels(); for (var x1 = 0; x1 \u0026lt; newimg.width; x1+=5) { for (var y1 = 0; y1 \u0026lt; newimg.height; y1+=5) { var indice = (x1 + y1 * newimg.width) * 4; var a = pixels[indice]; var a2 = pixels[indice + 1]; var a3 = pixels[indice + 2]; var a4 = pixels[indice + 3]; b = int(a3); histogram[b]++ } } image(img, 0, 0); stroke(250,20,200) push() translate(10,0) for (x1 = 0; x1 \u0026lt;= rango; x1++) { index2 = histogram[x1]; y2=int(map(index2, 0, max(histogram), height, height-200)); y3 = height xPos = map(x1,0,rango,0, width-20) line(xPos, y2, xPos, y3); } pop() } function convolution(img, x, y, matrix, sizem) { let r = 0.0; let g = 0.0; let b = 0.0; for (var i = -1; i \u0026lt; sizem - 1; i++) { for (var j = -1; j \u0026lt; sizem - 1; j++) { let px = x + i; let py = y + j; let index = (px + img.width * py)*4; index = constrain(index, 0, img.pixels.length - 1); r += img.pixels[index] * matrix[i+1][j+1]; g += img.pixels[index + 1] * matrix[i+1][j+1]; b += img.pixels[index + 2] * matrix[i+1][j+1]; } } return [r,g,b]; } function selection(value) { switch (value) { case \u0026#39;Ridge detection\u0026#39;: matrix = [ [ -1, -1, -1 ], [ -1, 8, -1 ], [ -1, -1, -1 ] ]; break; case \u0026#39;Sharpen\u0026#39;: matrix = [ [ 0, -1, 0 ], [ -1, 5, -1 ], [ 0, -1, 0 ] ]; break; case \u0026#39;Blur\u0026#39;: matrix = [ [ 1/9, 1/9, 1/9 ], [ 1/9, 1/9, 1/9 ], [ 1/9, 1/9, 1/9 ] ]; break; case \u0026#39;Convolution\u0026#39;: matrix = [ [ -1, -1, -1 ], [ -1, 9, -1 ], [ -1, -1, -1 ] ]; break; case \u0026#39;Unsharp masking\u0026#39;: matrix = [ [ -1/256, -4/256, -6/256, -4/256, -1/256 ], [ -4/256, -16/256, -24/256, -16/256, -4/256 ], [ -6/256, -24/256, 476/256, -24/256, -6/256], [ -4/256, -16/256, -24/256, -16/256, -4/256 ], [ -1/256, -4/256, -6/256, -4/256, -1/256 ]]; sizem = 5; break; default: matrix = [ [ -1, -1, -1 ], [ -1, 9, -1 ], [ -1, -1, -1 ] ]; break; } return matrix } function brillo(masomenos){ newimg.loadPixels(); for (var x = 0; x \u0026lt; img.width; x++) { for (var y = 0; y \u0026lt; img.height; y++) { var index = (y * img.width + x) * 4; if(masomenos){ img.pixels[index] = constrain(img.pixels[index]*1.1,0,255); img.pixels[index+1] = constrain(img.pixels[index+1]*1.1,0,255); img.pixels[index+2] = constrain(img.pixels[index+2]*1.1,0,255); } else{ img.pixels[index] = constrain(img.pixels[index]/1.1,0,255); img.pixels[index+1] = constrain(img.pixels[index+1]/1.1,0,255); img.pixels[index+2] = constrain(img.pixels[index+2]/1.1,0,255); } } } img.updatePixels(); image(img, width/2, 0); } function keyPressed() { switch (key) { case \u0026#34;+\u0026#34;: brillo(true); break; case \u0026#34;-\u0026#34;: brillo(false); break; } } Discusión # Se discutió principalmente del uso del visual masking hoy en día, como una herramienta en la edición de fotografías y videos de formato digital, todo en base a cálculos matemáticos, visto en Image Kernels, y del uso que también se le puede dar para el análisis de la composición de las imágenes al aplicar una máscara y usar en conjunto otras herramientas como el Image Histogram.\nConclusiones # Se puede concluir que el uso del enmascaramiento como herramienta para la era digital es de gran utilidad ya que permite manipular y adaptar una imagen cuando es necesario para diferentes fines, como un “retoque” o un análisis que se le deba hacer, y durante el desarrollo del taller entendimos como esto es posible gracias a un código relativamente simple y corto que cualquiera con conocimientos básicos de programación podría entender.\n"},{"id":2,"href":"/showcase/docs/shortcodes/Workshop_2/Backroom/","title":"Backroom","section":"Workshop 2","content":" Workshop #2: 3d webgl application # Introducción # El modelamiento 3D es una herramienta que abre un mundo de posibilidades para representar el mundo real dentro del mundo digital. Inicialmente, los modelos en 2 dimensiones se utilizaban para diseñar todo tipo de invenciones, tales como: juegos, herramientas de desarrollo e incluso modelos de la vida real. Desde hace mucho tiempo, se utiliza el 2D y ha sido muy útil para los desarrolladores. Sin embargo, un mundo en 3 dimensiones es más semejante a la realidad, por lo que el modelamiento 3D desde hace ya varios años se ha convertido en una herramienta de representación de la realidad mucho más poderosa.\nPara modelar y representar cosas o aspectos de nuestro entorno utilizamos aplicaciones gráficas. Estas, tanto en 2D como en 3D, abren muchas posibilidades de diseño e interacción con el mundo digital. Por esto, WebGl busca acercar aún más (tanto a desarrolladores como a los apasionados por el modelamiento y la interacción gráfica) a utilizar recursos básicos en nuestro entorno digital como un navegador y una librería de Javascript, y así empezar a diseñar aplicaciones gráficas interactivas en la Web e incursionar en el mundo del modelamiento digital.\nMarco teórico # Para el desarrollo del presenta taller, es necesario entender los conceptos que los envuelven. El primero de ellos es WebGL, una especificación estándar que define una API implementada en JavaScript para la renderización de gráficos en 3D dentro de cualquier navegador web, el cual permite la combinación con todos los estándares web del navegador, permitiendo el procesamiento de canvas y la combinación con diferentes elementos de HTML. Es un motor de rasterización, el cual se ejecuta en la GPU de la computadora del desarrollador y que dibuja líneas, puntos y triángulos basados en el código suministrado. Adicionalmente, las instrucciones dadas son proporcionadas por WebGL en forma de pares de funciones, el sombreador de vértices y el sombreador de fragmentos, los cuales calculan las posiciones de vértices y calculan un color para cada píxel de lo primitivo que se está dibujando, respectivamente.\nUn componente fundamental de WebGL para el presente proyecto, es el de cámara, el cual utiliza propiedades matriciales y la aplicación de la matemática para visualización de imágenes según es requerido por el usuario. Las principales funcionalidades se encuentran en la rotación, movimiento e inversión de la visión del usuario, las cuales tienen múltiples aplicaciones en los campos de geografía y videojuegos, facilitando la inmersión en un campo de tres dimensiones.\nEl último de los conceptos importantes, es el de Backroom, siendo este la base del proyecto desarrollado. Los Backrooms es una leyenda urbana originada en un tablón de 4Chan en el año 2019, el cual inicialmente describe una habitación inquietante de origen y propósitos desconocidos. El impacto que generó la publicación permitió la extensión de este universo, que ahora describe un mundo alterno que se encuentra compuesto por una gran cantidad de niveles laberínticos y entidades que habitan allí, los cuales interactúan con las personas que accidentalmente caen allí.\nMétodo # Para el desarrollo de este taller se uso principalmete la biblioteca P5.js y sus funciones de objetos 3D, de estos se puede destacar el moviento de cámara, de personaje, creación de ambiente (columnas, paredes, suelo y techo) y colisiones.\nMovimiento de cámara # Para generar la sensación de movimiento en primera persona se desplaza la cámara utilizando las teclas, y se rota la dirección en la que apunta utilizando el movimiento del mouse. Para lograr esto, se utilizaron las funciones dispuestas en P5 para creación y manipulación de la cámara.\nfunction draw(){ background(0); noStroke(); cam.pan(ang(-D.cx)); cam.tilt(ang(D.cy)); D.r-=(mx*sensitivityX); yAng-=(my*sensitivityY); cam.setPosition(D.x,-D.y,D.z); Corrección de cámara # Para mantener la cámara dentro de la ventana cuando se deja de mover el mouse después de un movimiento suave devuelve sus variables D.x, D.y y D.z a 0.\nif(mx \u0026gt; 0){ mx--; } if(mx \u0026lt; 0){ mx++; } if(my \u0026gt; 0){ my--; } if(my \u0026lt; 0){ my++; } Al hacer un movimiento fuerte y prolongado de la cámara giraría sin control, pero se utilizó este limitador para que no suceda.\n//Evitar que la camara gire sin control if(mx\u0026gt;30 || mx \u0026lt;-30){ mx=0; } Movimiento de \u0026ldquo;personaje\u0026rdquo; # Para desplazar la cámara se desplazan las coordenadas de la cámara a una velocidad definida.\nD.cx=mx*sensitivityX; D.cy=my*sensitivityY; //Moviviento adelante if(keys[87] \u0026amp;\u0026amp; keyIsDown(16)){ playerSpeed=5; D.z-=cos(ang(D.r))*playerSpeed; D.x-=sin(ang(D.r))*playerSpeed; } if(keys[87]){ D.z-=cos(ang(D.r))*playerSpeed; D.x-=sin(ang(D.r))*playerSpeed; } //Moviviento atras if(keys[83]){ D.z+=cos(ang(D.r))*(playerSpeed-0.7); D.x+=sin(ang(D.r))*(playerSpeed-0.7); } //Moviviento izq if(keys[65]){ D.z-=cos(ang(D.r+90))*playerSpeed; D.x-=sin(ang(D.r+90))*playerSpeed; } //Moviviento derecha if(keys[68]){ D.z+=cos(ang(D.r+90))*playerSpeed; D.x+=sin(ang(D.r+90))*playerSpeed; } Creación de ambiente # Para facilitar la creación de niveles y mantener la escencia de un BACKROOM tradicional, la creación de varias estructuras es a traves de ciclos FOR, principalmente en las columnas, suelo y el techo.\nColumnas # Las columnas son una estructura para limitar las paredes y a nosotros los desarrolladores nos ayuda a ubicar puntos estrategicos en el nivel para su creación, y ayudar a crear un efecto que confunda al jugador haciendo que las habitasciones sean similares.\nDentro de la funcion draw() usamos un ciclo FOR anidado para crear las columnas del nivel, todas estan a la misma distacia una de la otra en el plano X y el plano Z.\nfor(var i = -2.5; i \u0026lt; 2.5; i++){ for(var j = -2.5; j \u0026lt; 2.5; j++){ push(); translate(i*500,1,j*500); rotateY(ang(90)); //fill(228,225,70); texture(walls); box(30,120,30); pop(); } } Paredes # Las paredes crean los pasillos y habitaciones del juego, se crean con la función pared() que definimos y crea un plano con la función plane() de P5. Además, le agregamos las coordenadas y modificación en los planos X, Y y Z.\nfunction pared(x,y,z,dx,dy,dz,l){ push(); translate(x,y,z); rotateX(ang(dx)); rotateY(ang(dy)); rotateZ(ang(dz)); texture(walls); fill(180,153,81); plane(l,110); pop(); Donde x, y \u0026amp; z son las coordenadas del punto de origen de la pared, dx, dy y dz son los ángulos de inclinación del plano y l es la longitud.\nTecho y suelo # Igual que las columnas se crean con un ciclo FOR y ayudan a limitar las habitaciones y pasillos en el juego.\n//Suelo for(var k = -20; k \u0026lt; 20; k++){ for(var l = -20; l \u0026lt; 20; l++){ push(); translate(k*100,50,l*100); rotateX(ang(90)); fill(100); texture(floor); plane(100); pop(); } } //Piso del piso push(); translate(0,100,0); rotateX(ang(90)); //fill(167, 164, 61); texture(floor); plane(10000); pop(); //Techo for(var k = -5; k \u0026lt; 5; k++){ for(var l = -5; l \u0026lt; 5; l++){ push(); translate(k*500,-90,l*500); rotateX(ang(90)); fill(100); texture(roof); plane(500); pop(); } } Texturas # Para añadir las texturas a los techos se utilizó la funcion de P5 texture() y las imágenes de las texturas.\nfunction preload() { roof = loadImage(\u0026#39;assets/images/techo.png\u0026#39;); walls = loadImage(\u0026#39;assets/images/walls.png\u0026#39;); floor = loadImage(\u0026#39;assets/images/floor.png\u0026#39;); } Colisiones # Al no tener una función definida para las colisiones limitaciones de movimiento al llegar a una pared con condicionales para que el jugador no pueda atravesarlas, es la creación de la habitación con sus coordenadas y mover al jugador a una posición atrás para dar la sensación de que no se puede avanzar más.\nif(D.z\u0026gt;=230){ D.z=229 } if(D.x\u0026gt;=230){ D.x=229 } if(D.z\u0026lt;=-1230){ D.z= -1229 } if(D.x\u0026lt;=-230 \u0026amp;\u0026amp; D.x\u0026gt;=-260 \u0026amp;\u0026amp; D.z\u0026gt;=-730 ){ D.x=-229 } if(D.x\u0026lt;-250 \u0026amp;\u0026amp; D.z\u0026gt;=-770 ){ D.z=-769; } if(D.x\u0026lt;-1230 ){ D.x=0; D.z=100; } Resultados # Aplicación completa. # La aplicación completa se puede visualizar en el siguiente link al repositorio donde está el código de la aplicación BACKROOM o clonando el repositorio y ejecutándolo de manera local.\nDiscusión # Teniendo como inspiración o idea fuente el concepto de las leyendas urbanas sobre los “Backrooms”, se discutió acerca de las características qué debe cumplir la aplicación para lograr transmitir un tipo de idea, en este caso, el del terror y suspenso causado por lo extraño del ambiente. Se consultaron fuentes referentes al tema del uso de la rotación y desplazamiento de la cámara y el uso de los colores y de las texturas en los objetos.\nTeniendo en cuenta lo mencionado anteriormente en el marco teórico, también se discutieron las aplicaciones del uso de la cámara en entornos digitales como videojuegos o distintas aplicaciones interactivas. De la misma manera, se conversó acerca de la importancia de aspectos como la disposición e interacciones de la cámara, junto a la ambientación, para simular situaciones o generar emociones en los usuarios y espectadores.\nConclusiones # Se puede concluir que el uso de la cámara, su rotación y desplazamiento, depende del propósito que se quiera lograr. En el caso del presente proyecto el uso de una cámara que se mantenga en primera persona dio mejores resultados para adaptarse al concepto original. Así como se puede considerar la cámara en tercera persona mejor para otros propósitos.\nAdemás, que la creación de una habitación y/o pasillo es en esencia el uso de traslación y rotaciones, que se adaptaron para crear este ambiente de Backroom, el uso de planos similares y repetitivos gracias a los ciclos FOR dan un toque tétrico que fue siempre el objetivo.\nSe pudo notar, adicionalmente, la importancia de librerías y aplicaciones preexistentes de diferentes funcionalidades, las cuales permiten un aprendizaje más eficiente de las diferentes posibilidades que tiene, en este caso, WebGL y P5.\n"},{"id":3,"href":"/showcase/Quienes_somos/Andres_Lopez/","title":"Andres Lopez","section":"¿Quiénes somos?","content":" Andrés Felipe López # Estudiante de Ingeniería de Sistemas y Computación\n"},{"id":4,"href":"/showcase/Quienes_somos/Juan_Callejas/","title":"Juan Callejas","section":"¿Quiénes somos?","content":" Juan Felipe Callejas # Estudiante de Ingeniería de Sistemas y Computación\n"},{"id":5,"href":"/showcase/Quienes_somos/Juliette_Lizarazo/","title":"Juliette Lizarazo","section":"¿Quiénes somos?","content":" Juliette Sofía Lizarazo # Estudiante de Ingeniería de Sistemas y Computación\n"},{"id":6,"href":"/showcase/Quienes_somos/Santiago_Sanchez/","title":"Santiago Sanchez","section":"¿Quiénes somos?","content":" Santiago Sánchez # Estudiante de Ingeniería de Sistemas y Computación\n"},{"id":7,"href":"/showcase/Quienes_somos/","title":"¿Quiénes somos?","section":"Introducción","content":" Integrantes # El grupo está conformado por\nAndres Lopez Andrés Felipe López # Estudiante de Ingeniería de Sistemas y Computación Juan Callejas Juan Felipe Callejas # Estudiante de Ingeniería de Sistemas y Computación Juliette Lizarazo Juliette Sofía Lizarazo # Estudiante de Ingeniería de Sistemas y Computación Santiago Sanchez Santiago Sánchez # Estudiante de Ingeniería de Sistemas y Computación "}]